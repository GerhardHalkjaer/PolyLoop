@page "/PictureCapture"
@using Services
@using Entities
@inject Service myServ
@inject IBIZ Biz
@using Production.Model
@rendermode InteractiveServer
@inject IJSRuntime JS
@using System.Diagnostics


@* <button @onclick="StartCameras">Start Cameras</button>
 *
 * <button @onclick="RequestCameras">Grant Camera Access</button>
 *@

<div>
    <video id="video1" autoplay playsinline crossorigin="anonymous" class="video-container" width="1280" height="960"></video>
   @*  <button @onclick="() => CaptureAndSend(0)">Capture Camera 1</button> *@
</div>
<div>
    <video id="video2" autoplay playsinline crossorigin="anonymous" class="video-container" width="1280" height="960"></video>
   @*  <button @onclick="() => CaptureAndSend(1)">Capture Camera 2</button> *@
</div>



@code {

    [Inject] NavigationManager Nav { get; set; } // Inject navigation service

    private bool _started = false;
    private string[] videoIds = { "video1", "video2" };
    private string oneDrivePath = Environment.GetEnvironmentVariable("OneDrive");

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_started)
        {
            _started = true;
            await InitializeProcess();
        }

    }

    private async Task InitializeProcess()
    {

        //first request access to camesras, then start the cameras
        //then snapshot with both cameras
        //then get the id's of the cameras
        //from the id's figure out what camera is for what TODO:figure out how to identify the cameras and save that info, maybe cookies?
        //then the img thats for weight send that to the img to text convertion.
        //then the img of the plastic itself send to server for saving.
        //Followed by stopping the cameras.
        //then move on the label printing.


        await RequestCameras();
        await StartCameras();

        string img1 = await CaptureImg(0);
        string img2 = await CaptureImg(1);

        List<string> listID = await GetVidpids();


        await SetProcessDate();




        await SendToServer(0, img1);
      //  await SendToServer(1, img2);



        await StopCameras();

        //TODO:


        Nav.NavigateTo("/PrintLabel");


    }

    /// <summary>
    /// sets the processed date of the packaged unit to now.
    /// </summary>
    /// <returns></returns>
    private async Task SetProcessDate()
    {
        Biz.packagedUnit.ProcessedDate = DateTime.Now;
    }

    /// <summary>
    /// get the id's of the cameras
    /// </summary>
    /// <returns></returns>
    private async Task<List<string>> GetVidpids()
    {
        List<string> listOfVidIDs = await JS.InvokeAsync<List<string>>("sendVidPids");

        return listOfVidIDs;
    }

    /// <summary>
    /// Initializes and starts both cameras by invoking the JavaScript function.
    /// </summary>
    /// <returns></returns>
    private async Task StartCameras()
    {
        //string[] videoIds = { "video1", "video2" };
        await JS.InvokeVoidAsync("startCameras", (object)videoIds);
    }

    /// <summary>
    /// Captures an image from the specified camera and sends it to the server.
    /// </summary>
    /// <param name="camIndex">The index of the camera (0 for first camera, 1 for second camera).</param>
    /// <returns></returns>
    private async Task<string> CaptureImg(int camIndex)
    {

        Debug.WriteLine("starter");
        string videoId = camIndex == 0 ? "video1" : "video2";
        Debug.WriteLine(videoId);
        try
        {
            Debug.WriteLine($"Attempting to capture image from: {videoId}");
            string base64Image = await JS.InvokeAsync<string>("captureImage",videoId);
            Debug.WriteLine($"Captured image (Base64 length: {base64Image?.Length ?? 0})");

            if (!string.IsNullOrEmpty(base64Image))
            {
                //await SendToServer(camIndex, base64Image);
                //TODO: change so it doesnt send to server but return the img.

                return base64Image;

            }
            else
            {
                Debug.WriteLine("No image captured.");
                return null;
            }
        }
        catch (TaskCanceledException ex)
        {
            Debug.WriteLine($"TaskCanceledException: {ex.Message}");
            return null;
        }
        catch (JSException ex)
        {
            Debug.WriteLine($"JSException: {ex.Message}");
            return null;
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Unexpected error: {ex.Message}");
            return null;
        }
    }

    private async Task StopCameras()
    {
        await JS.InvokeVoidAsync("stopCameras");
    }


    /// <summary>
    /// used to send the image to the server
    /// TODO: not yet implemented
    /// </summary>
    /// <param name="camIndex"></param>
    /// <param name="base64Image"></param>
    /// <returns></returns>
    private async Task SendToServer(int camIndex, string base64Image)
    {
        var imageData = new WebcamImage { CameraIndex = camIndex, Base64Data = base64Image };
        // await Http.PostAsJsonAsync("api/webcam/upload", imageData);


        // Remove the data URL prefix (if it exists)
        string base64 = imageData.Base64Data;
        if (base64.StartsWith("data:image"))
        {
            var commaIndex = base64.IndexOf(',');
            base64 = base64.Substring(commaIndex + 1);
        }

        // Decode the base64 string into bytes
        byte[] imageBytes = Convert.FromBase64String(base64);

        // File name
        string fileName = $"ID_{Biz.packagedUnit.Id}_image_{DateTime.Now.Ticks}.png";

        // Specify a path to save the image
        string filePath = Path.Combine($@"{oneDrivePath}\PolyLoopImg", fileName);

        // put filename in Biz.packagedUnit
        Biz.packagedUnit.ImagePath = fileName;

        // Write the bytes to a file
        await File.WriteAllBytesAsync(filePath, imageBytes);

        Console.WriteLine($"Image saved to: {filePath}");


        //TODO: change to oneDrive location.

    }

    /// <summary>
    /// used to request camera access from the browser
    /// else the browser will not allow the camera to be accessed the 2nd camera
    /// </summary>
    /// <returns></returns>
    private async Task RequestCameras()
    {
        await JS.InvokeVoidAsync("requestCameras");
    }

}




